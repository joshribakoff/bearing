#!/bin/bash
set -e

# Recover a base folder that's on the wrong branch
# Preserves uncommitted work by moving it to a proper worktree
# Usage: worktree-recover <base-folder>

SCRIPT_DIR="$(cd "$(dirname "$0")" && pwd)"
BEARING_DIR="$(dirname "$SCRIPT_DIR")"
WORKSPACE_DIR="$(dirname "$BEARING_DIR")"

if [ $# -lt 1 ]; then
    echo "Usage: worktree-recover <base-folder>"
    echo "Example: worktree-recover fightingwithai.com"
    echo ""
    echo "Fixes base folders that accidentally switched off main."
    echo "Uncommitted work is moved to a new worktree."
    exit 1
fi

BASE_FOLDER="$1"
BASE_DIR="$WORKSPACE_DIR/$BASE_FOLDER"

# Detect default branch (main or master)
DEFAULT_BRANCH=$(git -C "$BASE_DIR" symbolic-ref refs/remotes/origin/HEAD 2>/dev/null | sed 's@^refs/remotes/origin/@@')
if [ -z "$DEFAULT_BRANCH" ]; then
    # Fallback: check if main exists, else master
    if git -C "$BASE_DIR" rev-parse --verify origin/main >/dev/null 2>&1; then
        DEFAULT_BRANCH="main"
    else
        DEFAULT_BRANCH="master"
    fi
fi

if [ ! -d "$BASE_DIR/.git" ] && [ ! -f "$BASE_DIR/.git" ]; then
    echo "Error: $BASE_DIR is not a git repository"
    exit 1
fi

CURRENT_BRANCH=$(git -C "$BASE_DIR" rev-parse --abbrev-ref HEAD)

if [ "$CURRENT_BRANCH" = "$DEFAULT_BRANCH" ]; then
    echo "✓ $BASE_FOLDER already on $DEFAULT_BRANCH"
    exit 0
fi

echo "Found: $BASE_FOLDER on '$CURRENT_BRANCH' (expected: $DEFAULT_BRANCH)"

# Check for uncommitted changes (staged or unstaged)
HAS_CHANGES=false
if ! git -C "$BASE_DIR" diff --quiet 2>/dev/null || ! git -C "$BASE_DIR" diff --cached --quiet 2>/dev/null; then
    HAS_CHANGES=true
fi

# Check for untracked files
UNTRACKED=$(git -C "$BASE_DIR" ls-files --others --exclude-standard 2>/dev/null)
if [ -n "$UNTRACKED" ]; then
    HAS_CHANGES=true
fi

WORKTREE_DIR="$WORKSPACE_DIR/$BASE_FOLDER-$CURRENT_BRANCH"

if [ -d "$WORKTREE_DIR" ]; then
    echo "Error: Worktree $WORKTREE_DIR already exists"
    echo "Resolve manually: move changes there, then reset base"
    exit 1
fi

if [ "$HAS_CHANGES" = true ]; then
    echo "⚠️  Uncommitted changes detected"
    echo "Stashing changes..."
    git -C "$BASE_DIR" stash push --include-untracked -m "worktree-recover: moving to $WORKTREE_DIR"
fi

# Check for unpushed commits before switching
UPSTREAM="origin/$CURRENT_BRANCH"
if git -C "$BASE_DIR" rev-parse --verify "$UPSTREAM" >/dev/null 2>&1; then
    UNPUSHED=$(git -C "$BASE_DIR" log "$UPSTREAM..$CURRENT_BRANCH" --oneline 2>/dev/null)
    if [ -n "$UNPUSHED" ]; then
        echo ""
        echo "⚠️  Unpushed commits on $CURRENT_BRANCH:"
        echo "$UNPUSHED"
    fi
fi

# Checkout main FIRST (releases the branch so we can create worktree)
echo "Switching $BASE_FOLDER to $DEFAULT_BRANCH..."
git -C "$BASE_DIR" checkout "$DEFAULT_BRANCH"
git -C "$BASE_DIR" pull --ff-only 2>/dev/null || git -C "$BASE_DIR" pull

# NOW create worktree for the branch (branch is released)
echo "Creating worktree: $WORKTREE_DIR"
git -C "$BASE_DIR" worktree add "$WORKTREE_DIR" "$CURRENT_BRANCH"

# Register in local.jsonl
LOCAL_FILE="$WORKSPACE_DIR/local.jsonl"
FOLDER_NAME="$BASE_FOLDER-$CURRENT_BRANCH"
LOCAL_ENTRY="{\"folder\":\"$FOLDER_NAME\",\"repo\":\"$BASE_FOLDER\",\"branch\":\"$CURRENT_BRANCH\",\"base\":false}"
echo "$LOCAL_ENTRY" >> "$LOCAL_FILE"

# Pop stash in new worktree if we stashed
if [ "$HAS_CHANGES" = true ]; then
    STASH_REF=$(git -C "$BASE_DIR" stash list | head -1 | cut -d: -f1)
    if [ -n "$STASH_REF" ]; then
        git -C "$WORKTREE_DIR" stash pop "$STASH_REF"
        echo "✓ Moved uncommitted changes to $WORKTREE_DIR"
    fi
fi

if [ -n "$UNPUSHED" ]; then
    echo ""
    echo "Unpushed commits now in worktree. Push when ready:"
    echo "  git -C $WORKTREE_DIR push"
fi

echo ""
echo "✓ $BASE_FOLDER recovered (now on $DEFAULT_BRANCH)"
