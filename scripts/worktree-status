#!/bin/bash

# Show health status of all worktrees
# Usage: worktree-status [--json] [--refresh]

SCRIPT_DIR="$(cd "$(dirname "$0")" && pwd)"
BEARING_DIR="$(dirname "$SCRIPT_DIR")"
WORKSPACE_DIR="$(dirname "$BEARING_DIR")"
LOCAL_FILE="$WORKSPACE_DIR/local.jsonl"
HEALTH_FILE="$WORKSPACE_DIR/health.jsonl"

JSON_MODE=false
REFRESH=false
CACHED=false
SUMMARY_ONLY=false

while [[ $# -gt 0 ]]; do
    case $1 in
        --json) JSON_MODE=true; shift ;;
        --refresh) REFRESH=true; shift ;;
        --cached) CACHED=true; shift ;;
        --summary) SUMMARY_ONLY=true; shift ;;
        *) shift ;;
    esac
done

# Cache TTL: 5 minutes
CACHE_TTL=300

if [ ! -f "$LOCAL_FILE" ]; then
    echo "No local.jsonl found. Run worktree-sync first."
    exit 1
fi

# Check if we can use cache
use_cache=false
if [ "$CACHED" = true ] && [ -f "$HEALTH_FILE" ] && [ "$REFRESH" != true ]; then
    cache_age=$(($(date +%s) - $(stat -f %m "$HEALTH_FILE" 2>/dev/null || stat -c %Y "$HEALTH_FILE" 2>/dev/null)))
    if [ "$cache_age" -lt "$CACHE_TTL" ]; then
        use_cache=true
    fi
fi

if [ "$use_cache" = true ]; then
    # Read from cache
    if [ "$SUMMARY_ONLY" = true ]; then
        dirty=$(grep -c '"dirty":true' "$HEALTH_FILE" 2>/dev/null || echo 0)
        unpushed=$(grep '"unpushed":[1-9]' "$HEALTH_FILE" 2>/dev/null | wc -l | tr -d ' ')
        stale=$(grep -c '"prState":"MERGED"' "$HEALTH_FILE" 2>/dev/null || echo 0)
        total=$(wc -l < "$HEALTH_FILE" | tr -d ' ')
        echo "Health: $dirty dirty, $unpushed unpushed, $stale stale (cached)"
        exit 0
    fi
    if [ "$JSON_MODE" = true ]; then
        cat "$HEALTH_FILE"
    else
        echo "(Using cached data - run with --refresh for fresh scan)"
        echo ""
    fi
    # Fall through to display cached results below
fi

# Arrays for issues
declare -a DIRTY_WORKTREES
declare -a UNPUSHED_WORKTREES
declare -a STALE_WORKTREES
declare -a BASE_VIOLATIONS
declare -a DEAD_ENTRIES
HEALTHY_COUNT=0

# Clear health file for refresh
[ "$REFRESH" = true ] && rm -f "$HEALTH_FILE"
rm -f "$HEALTH_FILE.tmp"

# Scan all worktrees
while IFS= read -r entry; do
    folder=$(echo "$entry" | sed -n 's/.*"folder":"\([^"]*\)".*/\1/p')
    repo=$(echo "$entry" | sed -n 's/.*"repo":"\([^"]*\)".*/\1/p')
    branch=$(echo "$entry" | sed -n 's/.*"branch":"\([^"]*\)".*/\1/p')
    is_base=$(echo "$entry" | sed -n 's/.*"base":\([^,}]*\).*/\1/p')

    dir="$WORKSPACE_DIR/$folder"

    # Check if folder exists
    if [ ! -d "$dir" ]; then
        DEAD_ENTRIES+=("$folder")
        continue
    fi

    # Skip if not a git repo
    if [ ! -d "$dir/.git" ] && [ ! -f "$dir/.git" ]; then
        continue
    fi

    has_issue=false

    # Check for base folder violations
    if [ "$is_base" = "true" ]; then
        current_branch=$(git -C "$dir" rev-parse --abbrev-ref HEAD 2>/dev/null)
        default_branch=$(git -C "$dir" symbolic-ref refs/remotes/origin/HEAD 2>/dev/null | sed 's@^refs/remotes/origin/@@')
        [ -z "$default_branch" ] && default_branch="main"

        if [ "$current_branch" != "$default_branch" ] && [ "$current_branch" != "master" ] || \
           { [ "$default_branch" = "main" ] && [ "$current_branch" != "main" ]; } || \
           { [ "$default_branch" = "master" ] && [ "$current_branch" != "master" ]; }; then
            # Simplified: just check if base is on its expected default
            actual_default=$(git -C "$dir" symbolic-ref refs/remotes/origin/HEAD 2>/dev/null | sed 's@^refs/remotes/origin/@@')
            if [ -z "$actual_default" ]; then
                git -C "$dir" rev-parse --verify origin/main >/dev/null 2>&1 && actual_default="main" || actual_default="master"
            fi
            if [ "$current_branch" != "$actual_default" ]; then
                BASE_VIOLATIONS+=("$folder on '$current_branch' (expected: $actual_default)")
                has_issue=true
            fi
        fi
    fi

    # Check dirty (uncommitted changes)
    dirty_count=$(git -C "$dir" status --porcelain 2>/dev/null | wc -l | tr -d ' ')
    if [ "$dirty_count" -gt 0 ]; then
        DIRTY_WORKTREES+=("$folder|$dirty_count files")
        has_issue=true
    fi

    # Check unpushed commits
    current_branch=$(git -C "$dir" rev-parse --abbrev-ref HEAD 2>/dev/null)
    if git -C "$dir" rev-parse --verify "origin/$current_branch" >/dev/null 2>&1; then
        unpushed=$(git -C "$dir" log "origin/$current_branch..$current_branch" --oneline 2>/dev/null | wc -l | tr -d ' ')
        if [ "$unpushed" -gt 0 ]; then
            UNPUSHED_WORKTREES+=("$folder|$unpushed commits")
            has_issue=true
        fi
    fi

    # Check PR state (only for non-base worktrees, skip rate-limited)
    if [ "$is_base" != "true" ] && [ -n "$current_branch" ]; then
        pr_state=$(gh pr view "$current_branch" --repo "$repo" --json state -q '.state' 2>/dev/null)
        if [ "$pr_state" = "MERGED" ]; then
            STALE_WORKTREES+=("$folder|PR merged")
            has_issue=true
        fi
    fi

    [ "$has_issue" = false ] && ((HEALTHY_COUNT++))

    # Write per-worktree health to cache
    dirty_bool="false"
    [ "$dirty_count" -gt 0 ] && dirty_bool="true"
    pr_state_json="null"
    [ -n "$pr_state" ] && pr_state_json="\"$pr_state\""
    echo "{\"folder\":\"$folder\",\"dirty\":$dirty_bool,\"unpushed\":${unpushed:-0},\"prState\":$pr_state_json,\"lastCheck\":\"$(date -u +%Y-%m-%dT%H:%M:%SZ)\"}" >> "$HEALTH_FILE.tmp"

done < "$LOCAL_FILE"

# Atomically update health cache
[ -f "$HEALTH_FILE.tmp" ] && mv "$HEALTH_FILE.tmp" "$HEALTH_FILE"

# Output
if [ "$JSON_MODE" = true ]; then
    echo "{"
    echo "  \"dirty\": ["
    for i in "${!DIRTY_WORKTREES[@]}"; do
        IFS='|' read -r f d <<< "${DIRTY_WORKTREES[$i]}"
        [ $i -gt 0 ] && echo ","
        printf '    {"folder":"%s","detail":"%s"}' "$f" "$d"
    done
    echo ""
    echo "  ],"
    echo "  \"unpushed\": ["
    for i in "${!UNPUSHED_WORKTREES[@]}"; do
        IFS='|' read -r f d <<< "${UNPUSHED_WORKTREES[$i]}"
        [ $i -gt 0 ] && echo ","
        printf '    {"folder":"%s","detail":"%s"}' "$f" "$d"
    done
    echo ""
    echo "  ],"
    echo "  \"stale\": ["
    for i in "${!STALE_WORKTREES[@]}"; do
        IFS='|' read -r f d <<< "${STALE_WORKTREES[$i]}"
        [ $i -gt 0 ] && echo ","
        printf '    {"folder":"%s","detail":"%s"}' "$f" "$d"
    done
    echo ""
    echo "  ],"
    echo "  \"baseViolations\": ["
    for i in "${!BASE_VIOLATIONS[@]}"; do
        [ $i -gt 0 ] && echo ","
        printf '    "%s"' "${BASE_VIOLATIONS[$i]}"
    done
    echo ""
    echo "  ],"
    echo "  \"deadEntries\": ["
    for i in "${!DEAD_ENTRIES[@]}"; do
        [ $i -gt 0 ] && echo ","
        printf '    "%s"' "${DEAD_ENTRIES[$i]}"
    done
    echo ""
    echo "  ],"
    echo "  \"healthyCount\": $HEALTHY_COUNT"
    echo "}"
else
    echo ""
    echo "WORKTREE HEALTH SUMMARY"
    echo "======================="
    echo ""

    has_issues=false

    if [ ${#DIRTY_WORKTREES[@]} -gt 0 ]; then
        has_issues=true
        echo "DIRTY (uncommitted changes):"
        for item in "${DIRTY_WORKTREES[@]}"; do
            IFS='|' read -r f d <<< "$item"
            printf "  %-40s %s\n" "$f" "$d"
        done
        echo ""
    fi

    if [ ${#UNPUSHED_WORKTREES[@]} -gt 0 ]; then
        has_issues=true
        echo "UNPUSHED (commits not pushed):"
        for item in "${UNPUSHED_WORKTREES[@]}"; do
            IFS='|' read -r f d <<< "$item"
            printf "  %-40s %s\n" "$f" "$d"
        done
        echo ""
    fi

    if [ ${#STALE_WORKTREES[@]} -gt 0 ]; then
        has_issues=true
        echo "STALE (PR merged, worktree lingering):"
        for item in "${STALE_WORKTREES[@]}"; do
            IFS='|' read -r f d <<< "$item"
            printf "  %-40s %s\n" "$f" "$d"
        done
        echo ""
    fi

    if [ ${#BASE_VIOLATIONS[@]} -gt 0 ]; then
        has_issues=true
        echo "BASE VIOLATIONS (should be on main/master):"
        for item in "${BASE_VIOLATIONS[@]}"; do
            echo "  $item"
        done
        echo ""
    fi

    if [ ${#DEAD_ENTRIES[@]} -gt 0 ]; then
        has_issues=true
        echo "DEAD ENTRIES (folder doesn't exist):"
        for item in "${DEAD_ENTRIES[@]}"; do
            echo "  $item"
        done
        echo ""
    fi

    if [ "$has_issues" = false ]; then
        echo "âœ“ No issues found"
        echo ""
    fi

    echo "Summary: $HEALTHY_COUNT healthy, ${#DIRTY_WORKTREES[@]} dirty, ${#UNPUSHED_WORKTREES[@]} unpushed, ${#STALE_WORKTREES[@]} stale"
fi
